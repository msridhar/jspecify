<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (18) -->
<title>Nullable (jspecify 0.0.0-SNAPSHOT API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: org.jspecify.nullness, annotation type: Nullable">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Field</li>
<li>Required</li>
<li>Optional</li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Element</li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li>Optional</li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Element</li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.jspecify.nullness</a></div>
<h1 title="Annotation Interface Nullable" class="title">Annotation Interface Nullable</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="annotations"><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Documented.html" title="class or interface in java.lang.annotation" class="external-link">@Documented</a>
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Target.html" title="class or interface in java.lang.annotation" class="external-link">@Target</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/ElementType.html#TYPE_USE" title="class or interface in java.lang.annotation" class="external-link">TYPE_USE</a>)
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Retention.html" title="class or interface in java.lang.annotation" class="external-link">@Retention</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME" title="class or interface in java.lang.annotation" class="external-link">RUNTIME</a>)
</span><span class="modifiers">public @interface </span><span class="element-name type-name-label">Nullable</span></div>
<div class="block">Indicates that the annotated type usage (commonly a variable type or return type) is considered
 to include <code>null</code> as a value.

 <p>Example usages:

 <pre><code>
 @Nullable String field;

 @Nullable String getField() { return field; }

 void setField(@Nullable String value) { field = value; }

 List&lt;@Nullable String&gt; getList() { … }
 </code></pre>

 <p>For a guided introduction to JSpecify nullness annotations, please see the <a href="http://jspecify.org/docs/user-guide">User Guide</a>.

 <p><b>Warning:</b> These annotations are under development, and <b>any</b> aspect of their
 naming, locations, or design is subject to change until the JSpecify 1.0 release. Moreover,
 supporting analysis tools will be tracking the changes on varying schedules. Releasing a library
 using these annotations in its API is <b>strongly discouraged</b> at this time.

 <h2 id="augmented-types">Augmented types</h2>

 <p><code>javac</code>‘s type system ignores this annotation: in all the examples above, the type it
 recognizes is "string (of ambiguous nullness)", as always. <code>javac</code> always treats a variable
 of such type <i>leniently</i>: you can freely assign <code>null</code> to it (as if it's nullable),
 yet you can freely deference it as well (as if it's non-null). We call this type the <b>base
 type</b>.

 <p>It's the function of a JSpecify-compatible <b>nullness analyzer</b> to interpret <code>
 String</code> and <code>@Nullable String</code> (for example) as <i>though</i> they are properly distinct
 types. (We will use <code>String</code> as a convenient example type throughout this documentation.)
 We call a base type together with its nullness indicator (usually, "nullable" or "non-null") an
 <b>augmented type</b>.

 <h2 id="notation">Important note on notation</h2>

 <p>Augmented types are indicated in prose using a <b>shorthand</b>, combining a base type with a
 symbol representing a nullness indicator. (<a href="https://bit.ly/3ppb8ZC">Why?</a>)

 <ul>
   <li><code>String!</code> represents the <b>non-null form</b> of the base type <code>String</code>: a
       reference to an actual string object. This might be expressed in Java code as
       <code>@NonNull String</code>, or, within null-marked code, as just <code>String</code>.
   <li><code>String?</code> represents the <b>nullable form</b> of the base type <code>String</code>: a
       "string-or-null". This is usually expressed in Java as <code>@Nullable String</code>.
   <li><code>String*</code> represents the <b>unspecified form</b>, as we would find in fully
       unannotated code. This is included here to round out the set; a proper explanation of
       unspecified nullness is in the <a href="http://jspecify.org/docs/user-guide">User
       Guide</a>.
   <li>A type variable with no suffix, like <code>T</code>, has <a href="NullMarked.html#special-cases">parametric nullness</a>. Any suffix above would
       indicate a <i>projection</i> of the type variable (see below).
 </ul>

 <p>For a complex example, a nullable array containing non-null arrays, in turn containing strings
 of unspecified nullness, would be written <code>String*[]![]?</code>. For a parameterized type, the
 suffix appears immediately after the class name (<code>Foo!&lt;Bar?&gt;</code>) rather than after the entire
 type (<code>Foo&lt;Bar?&gt;!</code>).

 <p>A tool might use this shorthand in its error messages, but be aware that it might follow its
 own similar but different scheme instead.

 <h2 id="subtypes">Subtypes</h2>

 <p>The Java Language Specification defines the subtype relation among base types. That definition
 is extended here to cover augmented types: specifically, the non-null form of any base type is a
 subtype of its nullable form. This relation extends transitively: for a base type <code>Foo</code>
 with supertype <code>SuperFoo</code>, the augmented type <code>Foo!</code> is a subtype of <code>Foo?</code>, of
 <code>SuperFoo!</code>, and of <code>SuperFoo?</code>. [TODO: diagram this.]

 <p>(How types with unspecified nullness fit into this picture requires <a href="http://jspecify.org/docs/user-guide">more explanation</a>.)

 <p>In <i>general</i>, for any scenario where the Java Language Specification checks for
 subtyping, this extended definition applies. For example, array covariance respects it: <code>
 Foo![]</code> is a subtype of <code>Foo?[]</code>. Generics are still invariant, so <code>List!&lt;Foo!&gt;</code> is
 <i>not</i> a subtype of <code>List!&lt;Foo?&gt;</code>, but it is a subtype of <code>List!&lt;? extends
 Foo?&gt;</code>.

 <p>This makes <code>Object?</code> the new "top type" of the hierarchy: the common supertype of every
 reference type. One consequence is that <code>List&lt;? extends Object&gt;</code> no longer means "any
 list": it now excludes lists with null elements, unlike <code>List&lt;?&gt;</code>.

 <h2>Kinds of type usages</h2>

 <p>The essential meaning of this annotation is always the same: the type in use is considered to
 include <code>null</code> as a value. But this may affect your code a little differently based on the
 kind of type usage involved. Still using the examples at top:

 <ul>
   <li>On a <b>parameter type:</b> The <code>setField</code> method permissively accepts a
       "string-or-null", meaning that it is okay to pass an actual string, or to pass <code>
       null</code>. (This doesn't guarantee that passing <code>null</code> can't produce an exception at
       runtime, but it should be much less likely.)
   <li>On a <b>method return type:</b> The <code>getField</code> method returns a "string-or-null", so
       while the caller might get a string back, it should also address the possibility of getting
       <code>null</code> instead. (This doesn't guarantee there is any circumstance in which <code>
       null</code> <i>will</i> actually be returned.)
   <li>On a <b>field type:</b> The <code>field</code> field has the type "string-or-null", so at times
       it might hold a string, and at times it might hold <code>null</code>. (Of course, every field of
       a reference type <i>originally</i> holds <code>null</code>, but as long as the class ensures
       that its uninitialized states can't be observed, it's appropriate to overlook that fact.)
   <li>On a non-wildcard<b> type argument:</b> A type usage of "nullable string" appears
       <i>within</i> the compound type <code>List&lt;@Nullable String&gt;</code>. No matter how this type is
       used (return type, local variable type, etc.), this tells us the same thing: when using
       this type, every appearance of <code>E</code> in <code>List</code>'s member signatures will be
       considered nullable. For a list, this means it may contain null <i>elements</i>. If the
       list reference itself might be null as well, we can write <code>@Nullable List&lt;@Nullable
       String&gt;</code>, a "nullable list of nullable strings". Type arguments supplied to a generic
       method invocation or class instance creation expression work similarly.
   <li>On a<b> type parameter bound:</b> If a type parameter's upper bound is annotated with
       <code>@Nullable</code>, as in <code>class Foo&lt;T extends @Nullable Object&gt;</code>, that means that
       <code>T</code> may be bound to nullable types, as in <code>Foo&lt;@Nullable String&gt;</code>.
   <li>On a<b> type variable</b> usage: A type parameter, like the <code>E</code> in <code>interface
       List&lt;E&gt;</code>, defines a type variable of the same name, usable only <i>within</i> the scope of
       the declaring API element. In any example using <code>String</code> above, a type variable like
       <code>E</code> might appear instead. <code>@Nullable</code> continues to mean "or null" as always,
       but notably, this works without regard to whether the type argument is <i>already</i>
       nullable. For example, given <code>class Foo&lt;E extends @Nullable Object&gt;</code>, with a method
       <code>@Nullable E eOrNull()</code>, then whether <code>foo</code> is of type <code>Foo&lt;String&gt;</code> or
       <code>Foo&lt;@Nullable String&gt;</code>, the expression <code>foo.eOrNull()</code> is always nullable.
       Using <code>@Nullable E</code> in this way is called "nullable projection" (<a href="NonNull.html#projection">non-null projection</a> is likewise supported, but less
       commonly useful).
   <li>On a <b>nested type</b>: In most examples above, in place of <code>String</code> we might use a
       nested type such as <code>Map.Entry</code>. The Java syntax for annotating such a type as
       nullable looks like <code>Map.@Nullable Entry</code>.
   <li>On a <b>record component</b>: As expected, <code>@Nullable</code> here applies equally to the
       corresponding parameter type of the canonical constructor, and <i>if</i> an accessor method
       is generated, to that method's return type as well. An explicit accessor method, if
       present, is unaffected: it should be annotated explicitly. Note that checking the
       expected-non-null components can be done in a "compact constructor".
 </ul>

 <h2 id="applicability">Where it is not applicable</h2>

 <p>This annotation and <a href="NonNull.html" title="annotation interface in org.jspecify.nullness"><code>NonNull</code></a> are applicable to any type usage except the following
 cases, where they have no defined meaning:

 <ul>
   <li>On any<b> intrinsically non-null type usage</b>. Some type usages are incapable of
       including <code>null</code> by the rules of the Java language. Examples include any usage of a
       primitive type, the argument to <code>instanceof</code>, a method return type in an annotation
       interface, or the type following <code>throws</code> or <code>catch</code>. In such locations, a
       nullness annotation could only be contradictory (<code>@Nullable</code>) or redundant
       (<code>@NonNull</code>).
   <li>On the root type of a <b>local variable</b> declaration. The nullness of a local variable
       itself is not a fixed declarative property of its <i>type</i>. Rather it should be inferred
       from the nullness of each expression assigned to the variable, possibly changing over time.
       (<a href="https://bit.ly/3ppb8ZC">Why?</a>). Subcomponents of the type (type arguments,
       array component types) are annotatable as usual.
   <li>On the root type in a <b>cast expression</b>. To inform an analyzer that an expression it
       sees as nullable is truly non-null, use an assertion or a method like <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/Objects.html#requireNonNull(T)" title="class or interface in java.util" class="external-link"><code>Objects.requireNonNull(T)</code></a>. (<a href="https://bit.ly/3ppb8ZC">Why?</a>)
       Subcomponents of the type (type arguments, array component types) are annotatable as usual.
   <li>On a <b>class declaration</b>. Java permits any type-use annotation to be used as a class
       annotation (<code>@Annotation class Foo</code>). However, this is not a type usage, and JSpecify
       nullness annotations have no meaning in such a location. (<a href="https://bit.ly/3ppb8ZC">Why?</a>)
   <li>On a <b>type parameter or wildcard</b>: Java also permits any type-use annotation to be
       placed before a type parameter declaration (<code>class Foo&lt;@Annotation T&gt;</code>) or a wildcard
       type argument (<code>Foo&lt;@Annotation ? extends Bar&gt;</code>). However, these are not type usages,
       and JSpecify nullness annotations have no meaning in such locations. (<a href="https://bit.ly/3ppb8ZC">Why?</a>) The <i>bounds</i> of a type parameter or wildcard
       are type usages and are annotatable as usual.
   <li>On <i>any</i> part of a <b>receiver parameter</b> type (<a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-8.html#jls-8.4">JLS 8.4</a>).
 </ul>

 Whether the code is <a href="NullMarked.html" title="annotation interface in org.jspecify.nullness"><code>NullMarked</code></a> also has no consequence in these locations.

 <h2>Unannotated type usages</h2>

 <p>For a type usage where nullness annotations are <a href="#applicability">applicable</a> but
 not present, its nullness depends on whether it appears within <a href="NullMarked.html" title="annotation interface in org.jspecify.nullness">null-marked</a> code; see that class for details.</div>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
